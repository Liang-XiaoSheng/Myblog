---
title: 批处理脚本
date: 2022-09-10
updated: 2023-04-01
tags: 批处理
categories: 批处理
---

# 常用DOS命令

```shell
help                  # 显示Windows提供的命令列表
ver                   # 显示正在使用的MS-DOS版本
prompt                # 更改或重置cmd.exe提示符
shuntdown             # 关闭计算机，或注销当前用户
choice                # 为用户提供选项列表
------------------------------------------------------------
cmd                   # 调用命令提示符的另一个实例
cls                   # 清屏
rem                   # 注释
start                 # 在新窗口中启动程序或打开文档
exit                  # 退出DOS控制台
pause                 # 提示用户并等待输入一行
title                 # 设置控制台窗口中显示的标题
date                  # 设置或显示系统日期
time                  # 设置或显示系统时间
echo                  # 显示消息、打开或关闭命令回显
------------------------------------------------------------
dir                   # 列出目录内容
tree                  # 显示当前目录的树形结构
attrib                # 显示或设置当前目录中的文件的属性
cd                    # 切换目录或显示当前目录
md                    # 新建目录
copy                  # 复制文件
xcopy                 # 深拷贝
move                  # 移动文件或目录
ren                   # 重命名文件或目录
del                   # 删除文件
rd                    # 删除空目录
------------------------------------------------------------
type                  # 将一个或多个文件的内容打印到输出中
more                  # 一次显示一个或多个文件的内容
find                  # 在文件或输入中搜索字符串，输出匹配的行
comp                  # 比较2个文件的大小
fc                    # 列出两个文件之间的实际差异
sort                  # 从源文件获取输入，并按字母顺序排列其内容在控制台上输出
expand                # 从压缩的.cab文件柜文件中提取文件
------------------------------------------------------------
tasklist              # 列出任务，包括任务名称和进程ID(PID)
taskkill              # 结束一项或多项任务
------------------------------------------------------------
ipconfig              # 显示Windows IP配置
ping                  # 通过网络将ICMP/IP“回显”数据包发送到指定地址
net                   # 根据使用的命令提供各种网络服务
------------------------------------------------------------
diskpart              # 显示和配置磁盘分区的属性
subst                 # 将驱动器号分配给本地文件夹，显示当前分配或删除分配
vol                   # 显示卷标
label                 # 添加、设置或删除磁盘卷标
chkdsk                # 检查磁盘
format                # 以FAT16、FAT32或NTFS文件格式格式化磁盘
conver                # 将卷从FAT16或FAT32文件系统转换为NTFS文件系统
------------------------------------------------------------
set                   # 显示当前系统上的环境变量列表
path                  # 显示或设置PATH环境变量
assoc                 # 将扩展名与文件类型关联，显示现有关联或删除关联
driverquery           # 显示所有安装的设备驱动程序及其属性
systeminfo            # 显示计算机及其操作系统的配置
```

# 系统命令

```shell
convert <disk:> /fs:ntfs                 # 无损转换文件系统
nslookup                                 # 查询dns映射
```

## ipconfig、ping、arp

**ping**

```shell
ping <target>                            # 测试网络联通
----------------------------------------------------------------
    -n count                             # 要发送的回显请求数。
    -w timeout                           # 等待每次回复的超时时间(毫秒)。
    -s srcaddr                           # 要使用的源地址。
----------------------------------------------------------------
# ping本机11次，可用于批处理延时10秒。命令中的>nul为屏蔽输出。
ping -n 11 127.0.0.1 >nul
```

**ipconfig**

```shell
ipconfig                                 # 查看ip信息
----------------------------------------------------------------
    /all                                 # 查看完整的ip信息
    /displaydns                          # 查看dns缓存
    /flushdns                            # 清除dns缓存
```

**arp**

```shell
arp -a [ip]                              # 查看arp缓存表，缺省值ip显示所有arp项
arp -g [ip]                              # 同 -a
arp -s <ip> <mac>                        # 添加静态arp
arp -d [ip]                              # 删除静态arp，缺省值ip删除所有arp项
```

## 进程：tasklist、taskkill、start

**tasklist**

```shell
tasklist [/s <system> [/u <username> [/p <password>]]] 
[/m <module> | /svc | /v ] [/fi <filter>] [/fo <format>] [/nh]
----------------------------------------------------------------
    /s <system>              # 指定要连接的远程系统
    /u <username>            # 指定命令应在其下执行的用户上下文
    /p <password>            # 指定给定用户上下文的密码。 提示输入，如果省略
    /m <module>              # 列出当前使用给定的exe/dll名称的所有任务。如果未指定模块名称，则显示所有已加载的模块。
    /svc                     # 显示每个进程中托管的服务
    /v                       # 显示详细的任务信息
    /fi <filter>             # 显示一组符合过滤器指定条件的任务
    /fo <format>             # 指定输出格式。 有效值:TABLE，LIST，CSV。
    /nh                      # 指定“列标题”不应显示在输出中。 仅适用于TABLE和CSV格式。
```

**taskkill**

```shell
taskkill [/s <system> [/u <username> [/p <password>]]] 
[/fi <filter>] [/pid <process-id> | /im <imagename>] [/t] [/f]
----------------------------------------------------------------
    /s <system>              # 指定要连接的远程系统
    /u <username>            # 指定命令应在其下执行的用户上下文
    /p <password>            # 指定给定用户上下文的密码。 提示输入，如果省略
    /fi <filter>             # 应用过滤器来选择一组任务，允许使用通配符
    /pid <process-id>        # 指定要终止的进程的PID
    /im <imagename>          # 指定要终止的进程的映像名称，允许使用通配符
    /t                       # 终止指定的进程以及由其启动的任何子进程
    /f                       # 指定强制终止进程
----------------------------------------------------------------
# 例：
taskkill /im qq.exe
taskkill /f /im spoolsv.exe
taskkill /pid 1230 /pid 1241 /pid 1253
# 终止PID 分别为 1230 1241 1253的进程
```

**start**

```shell
start “title” <path> [options] <filename>      # 启动命令
# title可以省略，filename如带有空格或是特殊符号的，用""括起来。
----------------------------------------------------------------
    /min                                # 使开启的窗口最小化
    /max                                # 使开启的窗口最大化
    /low                                # 使用IDLE优先级
    /normal                             # 使用NORMAL优先级
    /abovenormal                        # 使用ABOVENORMAL优先级
    /belownormal                        # 使用BELOWNORMAL优先级
    /high                               # 使用HIGH优先级
    /realtime                           # 使用REALTIME优先级
----------------------------------------------------------------
start http://www.baidu.com
# 打开百度
----------------------------------------------------------------
start "" "%windir%\system32\NOTEPAD.EXE" "%userprofile%\桌面\abc.txt"
# 用NOTEPAD（记事本）打开桌面上的abc.txt。
----------------------------------------------------------------
start "" "%userprofile%\桌面\abc.doc"
# 这里start后面要加""才能启动文件abc.doc
# 如果start后没有""则表示把title省略了
# 此时文件名若有""的话start就会把它看作是标题，从而变成了省略文件名，就默认开启cmd了
# 所以在start后加上""就能防止这种意外的情况。
----------------------------------------------------------------
start /min "" "%windir%\system32\NOTEPAD.EXE" "%userprofile%\桌面\abc.txt"
# 用记事本最小化打开桌面的abc.txt。
```

## shutdown

```shell
shutdown [/i | /l | /s | /r | /a | /h | /e | /o] [/f]
         [/m \\computer][/t xxx][/d [p|u:]xx:yy [/c "comment"]]
----------------------------------------------------------------
    /i         显示图形用户界面(GUI),必须是第一个选项。
    /l         注销。这不能与 /m 或 /d 选项一起使用。
    /s         关闭计算机。
    /r         完全关闭并重启计算机。
    /a         中止系统关闭，这只能在超时期间使用。
    /h         休眠本地计算机，可以与 /f 选项一起使用。
    /e         记录计算机意外关闭的原因。
    /o         转到高级启动选项菜单并重新启动计算机。
               必须与 /r 选项一起使用。
    /m \\computer 指定目标计算机。
    /t xxx     将关闭前的超时时间设置为 xxx 秒。
               有效范围是 0-315360000 (10 年)，默认值为 30。
    /c "comment" 注释重启或关闭的原因，最多允许 512 个字符。
    /f         强制关闭正在运行的应用程序而不事先警告用户。
    /d [p|u:]xx:yy  提供重新启动或关闭的原因。
               p 指示重启或关闭是计划内的。
               u 指示原因是用户定义的。
               如果未指定 p 和 u，则重新启动或关闭是计划外的。
               xx 是主要原因编号(小于 256 的正整数)。
               yy 是次要原因编号(小于 65536 的正整数)。
----------------------------------------------------------------
shutdown -l
# 该命令只能注销本机用户，对远程计算机不适用。
----------------------------------------------------------------
at 12:00 shutdown -s
# 通过-s参数，在12：00执行关闭计算机。
----------------------------------------------------------------
shutdown -r -t 60
# 60秒后重启计算机。如果没有设置时间则默认为30秒。
----------------------------------------------------------------
shutdown -f -s -t 300
# 通过-f参数强制计算机300秒后关闭。
----------------------------------------------------------------
shutdown -a
# 当我们在遇到冲击波或震荡波病毒时，或是执行了上面的关机命令时
# 我们可以运用shutdown -a 终止当前的关机进程，这样就可以避免关机而造成的损失了。
```

# 注释：rem、::

```shell
rem <balabala...>                         # 注释命令，该命令后的内容不被执行，但能回显
:: <balabala...>                          # 注释命令，该命令后的内容不被执行，也不能回显
```

- 任何以冒号：开头的字符行,在批处理中都被视作标号, 而直接忽略其后的所有内容。
- 有效标号：冒号后紧跟一个以字母数字开头的字符串，goto 语句可以识别。
- 无效标号：冒号后紧跟一个非字母数字的一个特殊符号，goto 无法识别的标号，可以起到注释
  作用，所以 :: 常被用作注释符号，其实 : 也可起注释作用。
- **如果`Rem`的行数太多，可能会使代码变慢，因为最后还是需要执行批处理文件中的每行代码。**

# 回显：echo、@

```shell
echo                                     # 显示当前echo命令状态（off或on）
echo [{ on|off }]                        # 打开或关闭回显
@<command>                               # 关闭显示改行命令本身
----------------------------------------------------------------
echo <balabala...>  echo [{ on|off }]    # 显示一段信息
echo.                                    # 输出空行，“.”可以用，：；”／]＋\任一符号替代
echo <content> > <filenema>              # 建立新文件或增加文件内容
echo <reply>|<command>                   # 答复命令中的提问
----------------------------------------------------------------
# 例：用rd 命令删除时它将会询问你Y或N，利用echo可自动帮我们输入Y确认
@echo off
echo Y|rd /s c:\abc
pause
```

# 文件文件夹操作

## 目录切换：cd

```shell
cd <path>                       # 切换到目标路径
cd..                            # 返回上级目录
cd\                             # 切换到根目录
cd                              # 显示当前的完整路径，一般用通过%cd%引用
----------------------------------------------------------------
# 例：显示当前的完整路径
echo 当前路径是%cd%
```

- .表示当前目录，..表示上一层目录，\表示根目录

- 直接输入盘符，可以切换到对于盘符的根目录

## 列文件名：dir、tree

**dir**

```shell
dir [path]
    [/A[[:]attributes]] [/B] [/C] [/D] [/L] [/N]
    [/O[[:]sortorder]] [/P] [/Q] [/S]
    [/T[[:]timefield]] [/W] [/X] [/4]
----------------------------------------------------------------
    [path]        # 指定要列出的驱动器、目录和/或文件。
----------------------------------------------------------------
    /A            # 显示具有指定属性的文件。
    attributes    D 目录
                  R 只读文件
                  H 隐藏文件
                  A 准备存档的文件
                  S 系统文件
                  - 表示“否”的前缀
----------------------------------------------------------------
    /B            # 使用空格式(没有标题信息或摘要)。
    /C            # 在文件大小中显示千位数分隔符。这是默认值。用/-C来停用分隔符显示。
    /D            # 跟宽式相同，但文件是按栏分类列出的。
    /L            # 用小写。
    /N            # 新的长列表格式，其中文件名在最右边。
----------------------------------------------------------------
    /O            # 用分类顺序列出文件。
    sortorder     N 按名称(字母顺序)
                  S 按大小(从小到大)
                  E 按扩展名(字母顺序)
                  D 按日期/时间(从先到后)
                  G 组目录优先
                  - 颠倒顺序的前缀
----------------------------------------------------------------
    /P            # 在每个信息屏幕后暂停。
    /Q            # 显示文件所有者。
    /S            # 显示指定目录和所有子目录中的文件。
----------------------------------------------------------------
    /T            # 控制显示或用来分类的时间字符域。
    timefield     C 创建时间
                  A 上次访问时间
                  W 上次写入的时间
----------------------------------------------------------------
    /W            # 用宽列表格式。
    /X            # 显示为非 8dot3 文件名产生的短名称。格式是 /N 的格式，
                  # 短名称插在长名称前面。如果没有短名称，在其位置则显示空白。
    /4            # 用四位数字显示年
```

**tree**

```shell
tree [path]       # 以倒立树形式列出目录
----------------------------------------------------------------
    /F            # 显示目录和文件
```

-  `[/A[[:]attributes]]`、`[/O[[:]sortorder]]`、`[/T[[:]timefield]]` 这里可以省略其后的冒号“:”，但之间不能留有空格

## 文件属性：attrib

```shell
# 显示或更改文件属性
attrib [ R | -R] [ A | -A ] [ S | -S] [ H | -H] [path [/S [/D]]]
----------------------------------------------------------------
    -        # 清除属性。
    R        # 只读文件属性。
    A        # 存档文件属性。
    S        # 系统文件属性。
    H        # 隐藏文件属性。
----------------------------------------------------------------
    [path [/S [/D]]]   # 指定要处理的文件属性。
    /S       # 处理当前文件夹及其子文件夹中的匹配文件。
    /D       # 也处理文件夹。/d必需和/s一起使用
```

## 删除：del

```shell
# 删除一个或数个文件
DEL [/P] [/F] [/S] [/Q] [/A[[:]attributes]] <path>
ERASE [/P] [/F] [/S] [/Q] [/A[[:]attributes]] <path>
----------------------------------------------------------------
    /P       # 删除每一个文件之前提示确认。
    /F       # 强制删除只读文件。
    /S       # 从所有子目录删除指定文件。
    /Q       # 安静模式。删除全局通配符时，不要求确认。
----------------------------------------------------------------
    /A       # 根据属性选择要删除的文件。
    attributes    R  只读文件
                  S  系统文件
                  H  隐藏文件
                  A  存档文件
                  -  表示“否”的前缀
```

## 复制：copy、xcopy

**copy**

- copy只能复制文件，不能复制文件夹

```shell
copy <src> [des]
----------------------------------------------------------------
    [des]           # des缺省值为当前目录。
                    # des为文件名时可实现改名
    /Y              # 禁止提示您确认要覆盖现存的目标文件。
```

```shell
# 合并文件
copy { /B | /A } <file1> ＋ [file2] ＋... +[filen] [file_final]
----------------------------------------------------------------
    [file_final]    # 缺省值为file1的文件名
    /B              # 合并方式为Binary
    /A              # 合并方式为ASCII
```

- MP3文件在使用此方法连接后，能实现连续播放。

**xcopy**

```shell
# 复制文件和目录树
xcopy <src> [des] [/A | /M] [/D[:date]] [/P] [/S [/E]] [/V] [/W]
                  [/C] [/I] [/Q] [/F] [/L] [/G] [/H] [/R] [/T] [/U]
                  [/K] [/N] [/O] [/X] [/Y] [/-Y] [/Z]
                  [/EXCLUDE:file1[ file2][ file3]...]
----------------------------------------------------------------
    /S            # 复制非空的目录和子目录。如果省略 /s，xcopy 将在一个目录中工作。
    /E            # 复制所有子目录，包括空目录。
    /H            # 复制具有隐藏和系统文件属性的文件。
    /T            # 只复制子目录结构（即目录树），不复制文件。要复制空目录，必须包含 /e 选项。
    /Y            # 禁止提示您确认要覆盖现存的目标文件。
```

## md、rd、ren、move

**md**

```shell
# 创建目录
md <dir>                           # 创建单个目录
md <dir1> [dir2] [dir3] ...        # 同时创建多个目录
```

- dir中包含有空格或是特殊符号的，一定要用双引号“”括起来

**rd**

```shell
# 删除目录
rmdir [/S] [/Q] <dir>
rd [/S] [/Q] <dir>
----------------------------------------------------------------
    /S        # 同时删除指定目录下的所有子目录和文件
    /Q        # 安静模式，/s删除目录树时不要求确认
```

- 在不加任何参数时，rd命令只能删除空目录

**ren**

```shell
# 重命名
rename [file1] <file2>
ren [file1] <file2>
```

- file2只能为文件名，不能为路径
- 对于隐藏或系统属性的文件，只有把它们的属性去除后，ren命令才会执行

**move**

```shell
# 移动（重命名）文件（目录）
move [/Y | /-Y] <src> <des>
----------------------------------------------------------------
    /Y         # 取消确认改写一个现有目标文件的提示。
    /-Y        # 对确认改写一个现有目标文件发出提示。
```

- MOVE命令可以跨分区移动文件，却不可以跨分区移动文件夹。
- 跨分区移动文件时，如果目标位置存在同名文件，系统会提示：“文件存在”，命令将不会执行。
- 对于隐藏或系统属性的文件，只有把它们的属性去除后，move命令才会执行

# 变量

## 命令行参数

参数可以通过变量`％1`，`％2`，`％3`等从批处理文件中调用

**批处理文件**

```shell
@echo off 
echo %1 
echo %2 
echo %3
```

**运行命令**

```shell
Test.bat 1 2 3
```

**输出**

```shell
1 
2 
3
```

## set命令

**自定义变量**

```shell
set [/a] [var=[str]]             # 设置自定义变量，[/a]如果该值本质上是数值，则使用此开关
set /p var=str                   # 交互式界面获取变量值，提示语str
----------------------------------------------------------------
set variable=                    # 将清除变量variable的值，使其变成未定义状态。
set variable=""                  # 此时变量值并不为空，而是等于两个引号，即"" 
```

## 局部与全局变量

默认情况下，变量是整个命令提示符会话的全局变量。 

调用`SETLOCAL`命令，使变量局部在脚本的范围内。 

在调用`SETLOCAL`之后，任何变量赋值在调用`ENDLOCAL`，调用`EXIT`，或者当执行到达脚本中的文件结尾(EOF)时都会返回。

**批处理文件**

```shell
@echo off 
set globalvar=5
SETLOCAL
set var=13145
set /A var=%var% + 5
echo %var%
echo %globalvar%
ENDLOCAL
```

**输出**

```shell
13150
5
```

## 环境变量

如果有跨批处理文件使用的变量，那么最好使用环境变量。 当定义了环境变量，就可以通过`%`符号来访问它。

**批处理文件**

```shell
@echo off 
echo %JAVA_HOME%
```

**输出**

```shell
C:\Program Files\Java\jdk-14
```

# 表达式

## **数字表达式**

```shell
set /a <expression>            # /a命令行开关指定等号右边的字符串为数字表达式。
----------------------------------------------------------------
( )                 分组
! ~ -               一元运算符
* / %               算数运算符
-                   算数运算符
<< >>               二进制逻辑移位
&                   二进制按位“与”
^                   二进制按位“异”
|                   二进制按位“或”
= *= /= %= += -=    算数赋值
&= ^= |= <<= >>=    二进制运算赋值
,                   表达式分隔符
----------------------------------------------------------------
# 例:
set /p input=请输入计算表达式：
set /a var=%input%
echo  计算结果：%input%=%var%
```

- DOS计算只能进行整数运算，精确到整数，它是不支持浮点计算的！

- 除法只能精确到整数

- DOS计算只能精确到二进制32位，其中最高位为符号位（0 为正，1 为负），低位31 位为数值。

- 31个1换成十进制为2147483647，所以DOS 计算的有效值范围是-2147483648至2147483647

- 对于逻辑运算符,我们需要把他们用双引号引起来,也可以用转义字符\^

## 一般表达式

**快速参考**

```shell
.        # 通配符: 任意一个字符
*        # 重复: 前面一个字符或类别出现0或0次以上
^        # 行位置: 行首
$        # 行位置: 行末
[class]  # 字符类别: 任何在字符集中的字符
[^class] # 补字符类别: 任何不在字符集中的字符
[x-y]    # 范围: 在指定范围内的任何字符
\x       # Escape: 元字符 x 的文字用法
\<xyz    # 字位置: 字的开始
xyz\>    # 字位置: 字的结束
```

**\. 和 \***

```shell
findstr . 123.txt 或 findstr "." 123.txt
# 在文件123.txt中查找任意字符，不包括空行。
----------------------------------------------------------------
findstr .* 2.txt 或 findstr ".*" 2.txt
# 在文件123.txt中查找任意字符，包括空行。
----------------------------------------------------------------
findstr ac* 123.txt
# 在文件123.txt中查找出现一个“a”字符串，以及a后面出现过0次或者任意次c的字符行。
```

**\^ 和 \$**

```shell
findstr "^step" 123.txt
# 在文件123.txt中查找行首为step字符串的行。
----------------------------------------------------------------
findstr "step$" 123.txt
# 在文件123.txt中查找行尾为step字符串的行。
```

**\[class\]**

- 字符集里的元素可以是字母和数字和一般的半角字符，如:}{ ,.][等，但双引号"不被识别。
- 不能是汉字， 汉字不被正确解释（汉字不是ASCII码）。
- 如果在字符集内插入通配符和重复符号，即"[.*]"将会把 . 和 * 视为普通字符。

```shell
findstr "[0-9]" 123.txt
# 在文件123.txt中查找数字0－9的任意之一的行。
----------------------------------------------------------------
findstr "[a-zA-Z]" 123.txt
# 在文件123.txt中查找包括任意字母行。
----------------------------------------------------------------
findstr "[abcezy]" 2.txt
# 在文件123.txt中查找包括a b c e z y其中任意一字母的行。
----------------------------------------------------------------
findstr "M[abc][123]Y" 2.txt
#在文件123.txt中查找可以匹配 Ma1Y , Mb1Y, Mc1Y; Ma2Y , Mb2Y, Mc2Y; Ma3Y , Mb3Y, Mc3Y的行。
```

**\[\^class\]**

```shell
findstr "[^0-9]" 123.txt
# 过滤纯数字的行，不能有空格，如2323，6t6t则过滤不了
----------------------------------------------------------------
findstr "[^a-z]" 123.txt
# 过滤纯字母的行，不能有空格，如gdas，6t6t则过滤不了
----------------------------------------------------------------
findstr "[^add]" 123.txt
# 过滤仅含有由a d d三个字母组成的纯字母字符串的行。
```

**\\\<xyz 和 xyz\\\>**

```shell
# xyz可以是英文单词或数字，但不适用于汉字
----------------------------------------------------------------
findstr "\<echo" 123.txt
# 所有含有以echo为前缀的字符串的行，都匹配。
----------------------------------------------------------------
findstr "echo\>" 123.txt
# 所有含有以echo为后缀的字符串的行，都匹配。
----------------------------------------------------------------
findstr "\<end\>" 123.txt
# 精确匹配含单词end的行。
```

**转义字符 \\**

- 把表达式中的特殊字符(元字符)转化为普通字符。
- 如：\\. 、\\* 、\\\\ 、\\[ 、\\]?? 、\\-

```shell
findstr "\.abc" 123.txt
# 在文件123.txt中查找可以匹配“.abc”字符串的行
----------------------------------------------------------------
findstr "1\\" 123.txt 或findstr "1\\\\" 123.txt
# 在文件123.txt中查找可以匹配“1\”字符串的行
```

## 特殊符号

**重定向：> 和 >>**

- \> 重定向符,传递并且覆盖，将运行的结果传递到后面的范围
- 后边可以是文件,也可以是默认的系统控制台

```shell
echo hello120 >1.txt        # 新建立文件1.txt，内容为”hello120”（行尾有一空格,文件后有一空行）
(echo hello120)>1.txt       # 新建立文件1.txt，内容为”hello120”（行尾无空格,但文件后有一空行）
>1.txt echo hello120        # 新建立文件1.txt，内容为”hello120”（行尾无空格,但文件后有一空行）
----------------------------------------------------------------
>1.txt <nul set /p=hello120 # 新建立文件 1.txt，内容为”hello120”（行尾无空格,且文件后也无空行）
>1.txt set /p=hello120<nul  # 新建立文件 1.txt，内容为”hello120”（行尾无空格,且文件后也无空行）
----------------------------------------------------------------
# 如果上面的例子中1.txt原来有内容的话，在使用了>重定向符命令后，将会被新的内容覆盖掉
```

- \>\> 重定向符，将命令的输出结果追加到后面

```shell
echo hello120 >>1.txt
# 如果1.txt不存在，则新建立文件 1.txt，内容为”hello120”
# 如果1.txt存在，则把内容为”hello120”追加到其文末尾
----------------------------------------------------------------
echo hello> 1.txt
echo world>>1.txt
# 1.txt内容如下:
hello
world
```

**管道命令 |** 

- 命令管道符|表示把在它之前的命令或语句的执行结果作为在它之后的命令或语句的处理对象

```shell
tasklist | find /i "qq.exe" && taskkill /f /im qq.exe
# 将tasklist（进程列表）用传递符"|" 传递给find命令，执行查找QQ的进程。
----------------------------------------------------------------
echo Y|rd /s c:\abc
# 通过管道命令|将echo y的结果传给rd /s c:\abc命令，从而达到自动输入y 的目的。
```

**组合命令 &、&&、||**

```shell
<command1> & <command2> [& <command3>...]
# &符号允许同时执行多条命令，当第一个命令执行失败了，也不影响后边的命令执行
----------------------------------------------------------------
<command1> && <command2> [&& <command3>...]
# &&符号允许同时执行多条命令，当碰到执行出错的命令后将不再执行后面的命令
----------------------------------------------------------------
<command1> || <command2> [|| <command3>...]
# ||符号允许同时执行多条命令，当一条命令执行失败后才执行第二条命令
```

- 管道命令的优先级高于重定向命令，重定向命令的优先级高于组合命令。

**转义字符 ^** 

- 如：\^\>、\^\|、\^\|\^\|、\^\^
- 转义字符还可以用作续行符号
- 每行末尾有一个看不见的符号，即回车符，转义字符位于行尾时就让回车符失效了，从而起到了续行的作用。

```shell
# 例：
echo 这是^
一个^
句子
```

**引导变量 %** 

- 当百分号成对出现，并且其间包含非特殊字符时，一般做变量引用处理，比如：%var%、%str%

```shell
# 例
set str=abc
echo 变量 str 的值是： %str%
```

- 对形式参数的引用，单个百分号后面紧跟0～9这10个数字，如%0、%1、%2 。。。

```shell
%0            # 表示批处理文件本身，包括完整的路径和扩展名
%1至%9        # 表示第一个参数至第九个参数
```

- 出现在 set /a 语句中时，表示两数相除取余数它在命令行窗口和批处理文件中的写法略有差异
- 在命令行窗口中，只需要单个的%，在批处理文件中，需要连续两个百分号，写成%%
- 转义符号：如果要显示%本身时，需要在前面用%来转义。

```shell
# 在命令行窗口中，运行 set /a num=4%2 ，则结果将显示0，因为4除以2的余数为0
# 如果保存为批处理文件，则此语句将略有改变：
set /a num=4%%2
echo 4除以2的余数为 %num%
```

**界定符""**

-  在表示带有空格或特殊符号的路径时常要用""来将路径括起来。
-  表示其中的内容是一个完整的字符串。

```shell
# 例：
cd /d cd "d:\program files\^%*abc"
----------------------------------------------------------------
@echo off
set "var=abc 123"
echo %var%
pause
```

# 运算符

## 算术运算符

| 运算符 |       描述       |      示例       |
| :----: | :--------------: | :-------------: |
|   +    |  两个操作数相加  |  1+2 结果为：3  |
|   -    |  两个操作数相减  |  2-1 结果为：1  |
|   *    |  两个操作数相乘  |  2*3 结果为：6  |
|   /    |  两个操作数相除  | 3/2 结果为：1.5 |
|   ％   | 模运算符，取余数 |  3%2 结果为：1  |

## 关系运算符

| 运算符 |             描述             |         示例         |
| :----: | :--------------------------: | :------------------: |
|  equ   |   检查左对象是否等于右对象   | 2 equ 2 结果为：true |
|  neq   |  检查左对象是否不等于右对象  | 3 neq 2 结果为：true |
|  lss   |   检查左对象是否小于右对象   | 2 lss 3 结果为：true |
|  leq   | 检查左对象是否小于等于右对象 | 2 leq 3 结果为：true |
|  gtr   |   检查左对象是否大于右对象   | 3 gtr 2 结果为：true |
|  geq   | 检查左对象是否大于等于右对象 | 3 geq 2 结果为：true |

## 逻辑运算符

| 运算符 |      描述      |
| :----: | :------------: |
|  AND   | 逻辑"与"运算符 |
|   OR   | 逻辑"或"运算符 |
|  NOT   | 逻辑"非"运算符 |

## 赋值运算符

| 运算符 |                描述                |
| :----: | :--------------------------------: |
|   +=   | 两个操作数相加，结果赋只给左操作数 |
|   -=   | 两个操作数相减，结果赋只给左操作数 |
|   *=   | 两个操作数相乘，结果赋只给左操作数 |
|   /=   | 两个操作数相除，结果赋只给左操作数 |
|   %=   | 两个操作数取余，结果赋只给左操作数 |

## 按位运算符

| 运算符 |       描述       |
| :----: | :--------------: |
|   &    |  按位"和"运算符  |
|   \|   |  按位"或"运算符  |
|   ^    | 按位"异或"运算符 |

**真值表**

|  p   |  q   | p&q  | p\|q | p^q  |
| :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |
|  0   |  1   |  0   |  1   |  1   |
|  1   |  1   |  1   |  1   |  0   |
|  1   |  0   |  0   |  1   |  1   |

# 字符串

## set命令

```shell
set var=[value]                  # 创建字符串
set var=                         # 创建空字符串
set c=%a% and %b% %d%...         # 字符串插值，字符串连接
set /a var=<num>                 # 转换为整数
```

## **替换字符串**

```shell
%PATH:str1=str2%                 # 将字符串变量%PATH%中的str1 替换为str2
----------------------------------------------------------------
set a=bbs. bathome. cn
%a: =%     ----  "bbs.bathome.cn"
%a:bbs=%   ----  ".bathome.cn"
%a:b=a%    ----  "aas.aathome.cn"
```

## **截取字符串**

```shell
%a:~[m[,n]]%                    # 截取字符串
# %为变量标识符，a为变量名，冒号用于分隔变量名和说明部分
# m为偏移量（缺省为0），n为截取长度（缺省为全部）
----------------------------------------------------------------
a=bbs.bathome.cn
%a:~1,3%   ---- “bs.”           # 变量a偏离1位，截取3位字符。
%a:~1,-3%  ---- “bs.bathome”    # 变量a偏离1位，截取倒数第3位前的字符。
%a:~-3%    ---- “.cn”           # 变量a偏离-3位，截取倒数的3位字符。
%a:~-3,2%  ---- “.c”            # 变量a偏离-3位，截取倒数后3位的前两2位字符
%a:~3%     ---- “.bathome.cn”   # 变量a偏离3位，截取完后面的字符。
%a:~,3%    ---- “bbs”           # 变量a偏离0位，截取3位字符。
```

## 字符串长度函数

在DOS脚本中，没有定义用于查找字符串长度的长度函数。 可以使用自定义的函数实现这个目的

```shell
@echo off
set str=Hello World
call :strLen str strlen
echo String is %strlen% characters long
exit /b

:strLen
setlocal enabledelayedexpansion

:strLen_Loop
   if not "!%1:~%len%!"=="" set /A len+=1 & goto :strLen_Loop
(endlocal & set %2=%len%)
goto :eof
```

## 字符串查找：find、findstr

**find**

```shell
find [/V] [/C] [/N] [/I] [/OFF[LINE]] "string" <file>
----------------------------------------------------------------
    /V        # 显示所有未包含指定字符串的行。
    /C        # 仅显示包含字符串的行数。
    /N        # 显示行号。
    /I        # 搜索字符串时忽略大小写。
    /OFF[LINE]# 不要跳过具有脱机属性集的文件。
    string    # 指定要查找的字符串
    flie      # 指定要查找的文件。
```

**findstr**

```shell
findstr [/B] [/E] [/L] [/R] [/S] [/I] [/X] [/V] [/N] [/M] [/O] [/F:file]
        [/C:string] [/G:file] [/D:dir list] [/A:color attributes] [/OFF[LINE]]
        "string" <file>
----------------------------------------------------------------
    /B        # 在一行的开始配对模式。
    /E        # 在一行的结尾配对模式。
    /L        # 按字使用搜索字符串。
    /R        # 将搜索字符串作为一般表达式使用。
    /S        # 在当前目录和所有子目录中搜索匹配文件。
    /I        # 指定搜索不分大小写。
    /X        # 打印完全匹配的行。
    /V        # 只打印不包含匹配的行。
    /N        # 在匹配的每行前打印行数。
    /M        # 如果文件含有匹配项，只打印其文件名。
    /O        # 在每个匹配行前打印字符偏移量。
    /P        # 忽略有不可打印字符的文件。
    /OFF[LINE]# 不跳过带有脱机属性集的文件。
    /A:attr   # 指定有十六进位数字的颜色属性。请见 "color /?"
    /F:file   # 从指定文件读文件列表 (/代表控制台)。
    /C:string # 使用指定字符串作为文字搜索字符串。
    /G:file   # 从指定的文件获得搜索字符串。 (/代表控制台)。
    /D:dir    # 查找以分号为分隔符的目录列表
    string    # 指定要查找的字符串
    flie      # 指定要查找的文件。
----------------------------------------------------------------
例：
findstr "hello there" x.y'        # 在文件 x.y 中查找"hello"或"there"。
findstr /C:"hello there" x.y'     # 在文件 x.y 中查找"hello there"。
```

- 在使用 findstr "我 你 他" test.txt 的时候，并不能查找到内容
- 但是，加上/i或者/r之后就正确无误了，单个的纯中文字符串没有任何问题。

# 数组

## 创建数组

```shell
set a[0]=1                               # 创建数组
set list=1 2 3 4                         # 创建数组
```

## 在数组中创建结构

```shell
set obj[0].Name=Joe 
set obj[0].ID=1 
set obj[1].Name=Mark 
set obj[1].ID=2 
set obj[2].Name=Mohan 
set obj[2].ID=3 
```

## 数组长度函数

```shell
@echo off 
set Arr[0]=1 
set Arr[1]=2 
set Arr[2]=3 
set Arr[3]=4 
set "x=0" 
:SymLoop 

if defined Arr[%x%] ( 
   call echo %%Arr[%x%]%% 
   set /a "x+=1"
   GOTO :SymLoop 
)
echo "The length of the array is" %x%
```

# 高级语句

## if语句

```shell
if "str1"=="str2" <command1> [else <command2>]           # 判断两个字符串是否相等
```

```shell
if <value1> equ <value2> <command1> [else <command2>]   # 判断两个数值是否相等
----------------------------------------------------------------
equ        # 等于
gtr        # 大于
geq        # 大于等于
lss        # 小于
leq        # 小于等于
neq        # 不等于
----------------------------------------------------------------
# 批处理中的大于号，小于号，等于号等等都不能用：“>”  “<”  “=” 这些符号，而要用像"gtr"这类的
# 如果要比较的两个元素加了双引号""，那么会被当成是字符的比较。
# 两个元素作比较的流程是：先比较两个元素的首位，如果首位相同，再比较第下一位...
# 例：if "12" lss "4" 语句中，实质是1与4的比较
```

```shell
if exist <file> <command1> [else <command2>]            # 判断驱动器，文件或文件夹是否存在
```

```shell
if defined <var> <command1> [else <command2>]           # 判断变量是否已经定义
----------------------------------------------------------------
# 当变量不存在或是值为空时，变量则为未定义。
# 这里变量为不使用引导符号%的变量名，不能用写为%变量%，否则出错。
```

```shell
if errorlevel <num> <command1> [else <command2>]        # 判断上个命令的返回值
----------------------------------------------------------------
if errorlevel 0 cmmand                                  # 如果返回的错误码值大于或等于0的时候，将执行cmmand操作
if %errorlevel%==0 cmmand                               # 如果返回的错误码值等于0的时候，将执行cmmand操作。
```

- if not 语句
- 对于if语句前面的5种基本语法，都可以加上not参数
- if语句可以嵌套使用

## for语句

```shell
for %%I in <command1> do <command2>
----------------------------------------------------------------
# command1表示的元素可以是一个，也可以是多个
# 每个元素之间用空格键、跳格键、逗号、分号或等号分隔
----------------------------------------------------------------
# 例：
for %%I in (bbs,bathome,cn) do echo %%I    # 结果会分三行显示
for %%i in (*.*) do echo "%%i"             # 显示当前目录所有文件
for %%i in (*.txt) do echo "%%i"           # 显示当前目录所有文本文件
for %%i in (??.txt) do echo "%%i"          # 显示当前目录所有名称为两位字符的文本文件
```

**处理文本文件**

```shell
for /f                                      # 以行为单位处理文本文件
----------------------------------------------------------------
@echo off
for /f %%i in (test.txt) do echo %%i
pause　　
```

**切分字符串**

```shell
delims=                                   # 切分字符串
----------------------------------------------------------------
# 例：
@echo off
for /f "delims=," %%i in (test.txt) do echo %%i
pause　　
----------------------------------------------------------------
"delims=，"                               # 以逗号作为被处理的字符串的分隔符号。
"delims=.，"                              # 以逗号和点号切分
```

- 如果没有指定`delim=`，`for /f `语句默认以空格键或跳格键作为分隔符号

**定点提取**

```shell
tokens=                                  # 定点提取
----------------------------------------------------------------
# tokens= 后面一般跟的是数字，每个数字之间用逗号分隔
# 如tokens=3,5,8；表示提取第3、第5和第8节字符串，这里的“节”，是由delims=划分的
----------------------------------------------------------------
# 例：
@echo off
for /f "delims=， tokens=1,2,3,4,5" %%i in (test.txt) do echo %%i %%j %%k %%l %%m
pause　　
----------------------------------------------------------------
# 如果tokens= 后面指定了多个数字，形式变量遵循字母的排序
# 如果第一个形式变量是%%i，第二个形式变量就是%%j
# 如果第一个形式变量是%%x，第二个形式变量就是%%y
----------------------------------------------------------------
# 提取连续的多节内容，可以只写最小值和最大值，中间用短横连接
# 如 tokens=1,2,3,4,5 可以简写为 tokens=1-5 。
# 例：tokens=1,2-5，tokens=1-3,4,5，tokens=1-4,5...
----------------------------------------------------------------
# *的使用
for /f "delims=， tokens=1,*" %%i in (test.txt) do echo %%i %%j
# 提取前面数字表示的节数之后，后面整体内容被*所表示的一个变量接收
```

**跳行处理**

```shell
skip=n                                   # 跳过n行
----------------------------------------------------------------
@echo off
for /f "skip=2" %%i in (test.txt) do echo %%i
pause　　
# 这段代码将跳过头两行内容，从第3行起显示test.txt中的信息。
```

**忽略指定字符开头的行**

```shell
eol=                                   # 忽略以指定字符打头的行，只能指定一个字符
----------------------------------------------------------------
例：
FOR /F "eol=; tokens=2,3* delims=, " %i in (myfile.txt) do @echo %i %j %k
# 忽略以分号打头的那些行
```

- `for /f `语句默认忽略以分号打头的行

```shell
for /f %%i in (文件名) do (……)
# 当你希望读取文本文件中的内容的话，第一个括号中不用任何符号包裹
for /f %%i in ('命令语句') do (……)
# 当你读取的是命令语句执行结果中的内容的话，第一个括号中的命令语句必须使用单引号包裹
for /f %%i in ("字符串") do (……)　
# 当你要处理的是一个字符串的时候，第一个括号中的内容必须用双引号括起来
----------------------------------------------------------------
# usebackq
# usebackq是一个增强型参数，当使用了这个参数之后，原来的for语句中第一个括号内的写法要做如下变动：
for /f "usebackq" %%i in ("文件名") do (……)
# 如果第一个括号里的对象是文件名的话，要用双引号"括起来。
for /f "usebackq" %%i in (`命令语句`) do (……)
# 如果第一个括号里的对象是一条命令语句的话，原来的单引号'要改为后引号`
for /f "usebackq" %%i in ('字符串') do (……)　
# 如果第一个括号里的对象是字符串的话，原来的双引号"要改为单引号'
```

**for /d 参数**

- 这个参数主要用于目录搜索,不会搜索文件
- 只能搜索指定目录和缺省情况当前目录下的目录名字，不搜索子目录。

```shell
for /d %%var in (set) do <command>            # 查询目录
----------------------------------------------------------------
# 例:
@echo off
for /d %%i in (c:\*) do echo %%i
pause
# 执行后会把C盘根目录下的全部目录名字打印出来,而文件则不显示!
```

**for /r 参数**

```shell
for /r [path] %%var in (set) do <command>    # 遍历搜索当前或指定路径下的文件名字
----------------------------------------------------------------
# path缺省值当前目录
# 如果集仅为一个单点(.)字符，则枚举该目录树
# set如果含有通配符(？或*)，则列举指定目录下（包括子目录）与set相符合的所有文件
# 如果set中为具体文件名，则枚举该目录树，而不管set中的指定文件是否存在。
----------------------------------------------------------------
# 例：
@echo off
for /r c:\ %%i in (boot.ini) do echo %%i
pause
# 执行后，不管boot.ini是否存在都将枚举c盘所有目录
----------------------------------------------------------------
# 为了只列举 boot.ini 存在的目录，我们可改成下面这样
@echo off
for /r c:\ %%i in (boot.ini) do if exist %%i echo %%i
pause
```

- `for /r`不会遍历隐藏文件！

**for /l 参数**

```shell
for /L %%var in (start,step,end) do <command>  # 建立序列
----------------------------------------------------------------
# (start,step,end)表示以增量或者递减形式从开始到结束的一个数字序列。
# 如：(1,1,5)将产生序列1 2 3 4 5，(5,-1,1) 将产生序列5 4 3 2 1
----------------------------------------------------------------
# 例：
@echo off
for /l %%i in (1,1,5) do echo %%i
pause
```

## goto语句

将cmd.exe定向到批处理程序中带标签的行

```shell
goto label                                      # 跳转到label行

: label                                         # 标签，必须单独一行，并且以冒号打头
<balala...>
<balala...>
...
<balala...>
```

# 延迟环境变量扩展

## 变量扩展

- CMD在读取命令时发现%，会把它当作一个变量处理，找到变量名对应的值换掉这个变量名(如果变量名不存在值,就返回空值)，再执行

- 这个替换值的过程,就叫做变量扩展

- 此时，如果使用if、for等嵌套语句，在括号里面嵌入一些设置变量值的命令,就会出现问题了!

## 延迟环境变量扩展

- 在我们启用了"延迟环境变量扩展"后，当CMD在解释含有嵌套格式的命令时，他会把嵌套的命令一条一条的先执行一次,，然后再进行匹配操作；

- 并且在"延迟环境变量扩展"启用后，CMD会用!号来判断这是不是一个变量；

- 如没启用前变量用%name%这样的格式判断，启用后就用!name!这样的格式判断了
- 延迟环境变量扩展特性在CMD中缺省是关闭的，开启它的方法目前有两个：
  - `cmd /v:{on|off}`，开启或关闭延迟扩展，它会打开一个新的命令行外壳。
  - 在使用`exit`退出这个外壳之前，扩展特性始终有效，常用于命令行环境中
  - `setlocal EnableDelayedExpansion`，它会使环境变量的修改限制到局部空间中。
  - 在`endlocal`之后，扩展特性和之前对环境变量的修改将一同消失，常用于批处理语句中。

```shell
# 例：
@echo off
set mm=girl&echo %mm%
pause
# 执行后显示“ECHO 处于关闭状态”。
----------------------------------------------------------------
@echo off&setlocal EnableDelayedExpansion
set mm=girl&echo !mm!
pause
# 开启了变量延迟，变量扩展（替换）的行为就推迟到echo命令执行时
# 这时echo能感知它前面的命令，从而作出正确的判断并执行
----------------------------------------------------------------
@echo off
set var=abc
for /l %%i in (1 1 5) do (
    set var%%i=%%i
    echo %var%
)
echo %var1% %var2% %var3% %var4% %var5%
pause
# 若没有开启延迟变量，你就没法在复合语句中提取到它，要等复合语句运行完毕后，才能提取到。
----------------------------------------------------------------
@echo off
setlocal EnableDelayedExpansion
set var=abc
for /l %%i in (1 1 10) do (
    set var=%%i
    echo %var%
    echo !var!
)
Pause
# %var% 显示的结果是复合语句之前变量var的值，而 !var! 显示的就是复合语句中即时得到的值。
----------------------------------------------------------------
@echo off
setlocal EnableDelayedExpansion
for /l %%i in (1 1 5) do (
    set var%%i=%%i
)
echo %var1% %var2% %var3% %var4% %var5%
echo !var1! !var2! !var3! !var4! !var5!
pause
# 在开启了延迟变量的情况下，且在复合语句之外，用两种方法都可以表示变量
```

# 日期和时间

```shell
date                            # 设置、获取系统日期
echo %date%                     # 显示系统日期
time                            # 设置、获取系统时间
echo %time%                     # 显示系统时间
```

# 输入输出

- **stdin：**标准输入文件，包含程序/脚本的输入

- **stdout：**标准输出文件，用于输出以在屏幕上显示

- **stderr：**标准错误文件，包含在屏幕上显示的任何错误消息

这三个标准文件中的每一个，也称为作为标准流，使用数字0、1、2引用。Stdin是文件0，stdout是文件1，stderr是文件2。

**重定向运算符`>`将`stdout`或`stderr`重定向到另一个文件**

```shell
dir C:\ > list.txt              # 命令dir C:\ 的stdout被重定向到文件list.txt
dir C:\ 2> list.txt             # 将stderr重定向到文件lists.txt
dir C:\ > nul                   # 将输出重定向到nul来丢弃输出
```

# 函数

```shell
:function_name                  # 函数名称
do_something                    # 函数方法
exit /b 0                       # exit语句用于确保函数正确退出
----------------------------------------------------------------
call :function_name             # 调用函数
exit /b %errorlevel%            # 在主程序中放入exit /b %errorlevel%语句，以便将主程序的代码与函数分开
----------------------------------------------------------------
# 当函数调用时，函数可以通过传递参数来处理参数
# 通过使用代字符(~)以及参数的位置，来在函数内部访问参数
call :function_name [parameter1], [parameter2]… [parametern]
@echo off
setlocal
call :Display 5 , 10

:Display
echo The value of parameter 1 is %~1
echo The value of parameter 2 is %~2
exit /b 0
```

# 别名（宏）

```shell
doskey [options] [macroname=<text>]    # 创建别名(宏)
----------------------------------------------------------------
    /reinstall                # 安装Doskey的新副本
    /listsize=size            # 设置命令历史缓冲区的大小
    /macros                   # 显示所有Doskey宏
    /macros:all               # 显示所有可执行文件的Doskey宏
    /macros:exename           # 显示所有给定可执行文件的Doskey宏
    /history                  # 显示存储在内存中的所有命令
    /insert                   # 指定键入的新文本以旧文本插入
    /overstrike               # 指定新文本覆盖旧文本
    /exename=exename          # 指定可执行文件
    /macrofile=filename       # 指定要安装的宏文件
    macroname                 # 指定创建的宏的名称
    text                      # 指定要录制的命令
----------------------------------------------------------------
doskey cd = cd/test           # 将宏cd设置为cd/test
doskey d = dir                # 将宏d设置为dir
d=                            # 通过将宏的值设置为NULL来删除别名或宏
d=dir /w                      # 将宏d替换为dir /w
```

# 设备控制台

**DevCon**是一个命令行工具，可在本地计算机和远程计算机上执行设备管理功能。

DevCon可以显示驱动程序的以下属性 :

- 硬件ID，兼容ID，和设备实例ID

- 设备设置类

- 设备设置类中的设备

- INF文件和设备驱动程序文件

- 驱动程序包的详细信息

- 硬件资源

- 设备状态

- 预期的驱动程序堆栈

- 驱动程序存储区中的第三方驱动程序包

- 搜索设备DevCon可以通过硬件ID，设备实例ID或设备设置类在本地或远程计算机上搜索已安装和未安装的设备

- 更改设备设置DevCon可以通过以下方式更改本地计算机上即插即用(PnP)设备的状态或配置

  - 启用设备

  - 禁用设备
  - 更新驱动程序(交互式和非交互式)
  - 安装设备(创建devnode并安装软件)
  - 从设备中删除设备树并删除其设备堆栈
  - 重新扫描即插即用设备
  - 添加，删除和重新排序根枚举设备的硬件ID
  - 更改设备设置类的上下过滤器驱动程序
  - 从驱动程序存储区添加和删除第三方驱动程序包

**在安装WDK，Visual Studio和Windows SDK时包含DevCon安装时，DevCon.exe工具包在以下位置可用**

```shell
%WindowsSdkDir%\tools\x64\devcon.exe
%WindowsSdkDir%\tools\x86\devcon.exe
%WindowsSdkDir%\tools\arm\devcon.exe
```

**语法**	

```shell
devcon [/m:\\computer] [/r] <command> [arguments]
----------------------------------------------------------------
    /m:\\computer                # 在指定的远程计算机上运行该命令。反斜杠是必需的。
    /r                           # 有条件的重启，仅在需要重新启动以使更改生效时才重新启动系统。
    <command>                    # 指定一条DevCon命令
----------------------------------------------------------------
# 要列出并显示有关计算机上设备的信息，请使用以下命令
    DevCon HwIDs
    DevCon Classes
    DevCon ListClass
    DevCon DriverFiles
    DevCon DriverNodes
    DevCon Resources
    DevCon Stack
    DevCon Status
    DevCon Dp_enum
----------------------------------------------------------------
# 要搜索有关计算机上设备的信息，请使用以下命令
    DevCon Find
    DevCon FindAl
----------------------------------------------------------------
# 要操纵设备或更改其配置，请使用以下命令
    DevCon Enable
    DevCon Disable
    DevCon Update
    DevCon UpdateNI
    DevCon Install
    DevCon Remove
    DevCon Rescan
    DevCon Restart
    DevCon Reboot
    DevCon SetHwID
    DevCon ClassFilter
    DevCon Dp_add
    DevCon Dp_delete
```

# 注册表

注册表包含两个基本元素：键和值。 **注册表项**是与文件夹类似的容器对象。 **注册表值**是与文件类似的非容器对象。

键可能包含值或其他键。使用类似于Windows路径名的语法引用键，使用反斜杠表示层次结构级别。

**从注册表中读取**

```shell
REG QUERY [root\]RegKey /v ValueName [/s]                     # 从注册表中读取
REG QUERY [root\]RegKey /ve                                   # 从注册表中读取默认值
----------------------------------------------------------------
    <RegKey>                       # 需要在注册表中搜索的关键字。
----------------------------------------------------------------
REG QUERY HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Windows\    # 例
```

**添加到注册表中**

```shell
REG ADD [ROOT\]RegKey /v ValueName [/t DataType] [/S Separator] [/d Data] [/f]
REG ADD [ROOT\]RegKey /ve [/d Data] [/f]                      # 为该键添加(默认)的名称
----------------------------------------------------------------
    ValueName                     # 在选定的RegKey下的值，进行编辑
    /d Data                       # 要存储为“字符串”，整数等的实际数据
    /f                            # 强制更新而不提示“值存在，覆盖Y/N”
    /S Separator                  # 在REG_MULTI_SZ值中用作分隔符的字符。 默认值是"\0"
    /t DataType                   # 这些是根据注册表标准定义的数据类型,如下
        REG_SZ (默认)
        REG_DWORD
        REG_EXPAND_SZ
        REG_MULTI_SZ
----------------------------------------------------------------
REG ADD HKEY_CURRENT_USER\Console /v Test /d "Test Data"      # 例
```

**从注册表中删除**

```shell
REG DELETE [ROOT\]RegKey /v ValueName [/f] 
REG DELETE [ROOT\]RegKey /ve [/f]                              # 删除指定键下的缺省值
REG DELETE [ROOT\]RegKey /va [/f]                              # 删除指定键下的所有值
----------------------------------------------------------------
    ValueNam                      # 在选定的RegKey下的值，进行编辑
    /f                            # 强制更新而不提示“值存在，覆盖Y/N”
----------------------------------------------------------------
REG DELETE HKEY_CURRENT_USER\Console /v Test /f                # 例
```

**复制注册表项**

```shell
REG COPY [\\SourceMachine\][ROOT\]RegKey [\\DestMachine\][ROOT\]RegKey
----------------------------------------------------------------
REG COPY HKEY_CURRENT_USER\Console HKEY_CURRENT_USER\Console\Test    # 例   
```

**比较注册表项**

```shell
REG COMPARE [ROOT\]RegKey [ROOT\]RegKey [/v ValueName] [Output] [/s]
REG COMPARE [ROOT\]RegKey [ROOT\]RegKey [/ve] [Output] [/s]
----------------------------------------------------------------
    [Output]：od(仅差异)、os(仅匹配)、oa(全部)、on(不输出)
----------------------------------------------------------------
REG COMPARE HKEY_CURRENT_USER\Console HKEY_CURRENT_USER\Console\Test # 例       
```

# 网络

`NET`命令用于更新，修复或查看网络或网络设置

```shell
net account [/FORCELOGOFF:{minutes | NO}] [/MINPWLEN:length]
            [/MAXPWAGE:{days | UNLIMITED}] [/MINPWAGE:days] 
            [/UNIQUEPW:number] [/DOMAIN]
----------------------------------------------------------------
    FORCELOGOFF              	       # 在规定时间内强制注销当前用户
    MINPWLEN                           # 最小密码长度设置
    MAXPWAGE                           # 最大密码使用期限设置
    MINPWAGE                           # 最小密码使用期限设置


net config                             # 显示当前的服务器或工作组设置
net computer <\\pcname> [/add | /del]  # 从域数据库中添加或删除计算机
net stop/start [servicename]           # 停止和启动特定的服务
net statistics [SERVER/WORKSTATION]    # 显示工作站或服务器的网络统计信息


# 查看特定用户帐户的详细信息。添加一个用户帐户。删除用户的帐户。修改用户的帐户。
net user [username [password | *] [options]] [/DOMAIN] 
         [username [password | *]] /ADD [options] [/DOMAIN] 
         [username [password | *]] [/DELETE] [/DOMAIN]


# 连接或断开计算机与共享资源或显示有关您的连接的信息
net use [devicename | *] [\\computername\sharename[\volume] [password | *]] 
[/USER:[domainname\]username] 
[/USER:[dotted domain name\]username]
[/USER:[username@dotted domain name] 
[/SMARTCARD] 
[/SAVECRED] [[/DELETE] | [/PERSISTENT:{YES | NO}]]
----------------------------------------------------------------
    \\computername\sharename           # 需要连接的份额的名称
    /USER                              # 需要指定以确保在连接到网络共享时指定正确的凭据
```

# 打印

**net print**

```shell
print [/D:device] [[drive:][path]filename[...]]
----------------------------------------------------------------
    /D:device                           # 指定打印设备
----------------------------------------------------------------  
print c:\example.txt /c /d:lpt1         # 例：打印example.txt文件到并行端口lpt1
```

**printui.dll和rundll32.exe**

```shell
rundll32.exe printui.dll,PrintUIEntry [ options ] [ @commandfile ]
----------------------------------------------------------------  
    /dl                # 删除本地打印机
    /dn                # 删除网络打印机连接
    /dd                # 删除打印机驱动程序
    /e                 # 显示打印首选项
    /f [file]          # inf文件或输出文件
    /F [file]          # INF文件使用/f指定的INF文件的位置
    /ia                # 使用inf文件安装打印机驱动程序
    /id                # 使用添加打印机驱动程序向导安装打印机驱动程序
    /if                # 使用inf文件安装打印机
    /ii                # 使用添加打印机向导和inf文件安装打印机
    /il                # 使用添加打印机向导安装打印机
    /i                 # 添加网络打印机连接
    /ip                # 使用网络打印机安装向导安装打印机
    /k                 # 将测试页打印到指定的打印机，在安装打印机时不能与命令组合
    /l [path]          # 打印机驱动程序源路径
    /m [model]         # 打印机驱动程序型号名称
    /n [name]          # 打印机名称
    /o                 # 显示打印机队列视图
    /p                 # 显示打印机属性
    /Ss                # 将打印机设置存储到文件中
    /Sr                # 从文件恢复打印机设置
    /y                 # 将打印机设置为默认值
    /Xg                # 获取打印机设置
    /Xs                # 设置打印机设置
```

# 调试

**错误消息**

- step1：移除`@echo off`，即rem `@echo off`或`:: @echo off`
- step2：`test.bat > batch.log 2>&1`，将所有输出重定向到日志文件
- step3：在文件`batch.log`中搜索错误消息
- step4：检查上一行是否有任何意外或无效的命令
- step5：纠正错误并重复此过程，直到所有错误消息都消失

**复杂命令行**

- step1：在使用复杂命令集的行之前插入"命令检查行"
- step2：按照程序查找上述错误消息来源
- step3：特别注意“简化”命令行的输出:预期格式的输出是什么？ “令牌”值或位置是否如预期的那样

**子程序**

- step1：在脚本的开头添加并重置一个计数器变量`set counter = 0`
- step2：每次调用子程序时递增计数器，在子程序的开始插入`set /a counter+=1`
- step3：在计数器递增之后插入另一行，仅包含`SET`命令; 这将列出所有的环境变量及其值
- step4：按照程序查找上述错误消息源

# 日志

```shell
test.bat > testlog.txt 2> testerrors.txt          # 例
```

- 打开testerrors.txt文件，会显示错误信息

- 打开testlog.tx文件，会显示执行命令的日志

# 返回代码

**错误代码**

|             错误代码              |              描述              |
| :-------------------------------: | :----------------------------: |
|                 0                 |        程序已成功完成.         |
|                 1                 |           功能不正确           |
|                 2                 |      系统找不到指定的文件      |
|                 3                 |      系统找不到指定的路径      |
|                 5                 |            访问拒绝            |
|            90090x2331             | 程序无法识别作为内部或外部命令 |
| 2212254950xC0000017-  1073741801  |          虚拟内存不足          |
| 32212257860xC000013A-  1073741510 |    应用程序因CTRL + C而终止    |
| 32212257940xC0000142-  1073741502 |     应用程序未能正确初始化     |

**错误级别**

- 环境变量`％errorlevel％`包含上次执行的程序或脚本的返回码

- 通常在批处理文件末尾使用命令`exit /b ％errorlevel％`从批处理文件返回错误代码

- 批处理文件末尾的`exit /b`将停止执行批处理文件

- 使用`exit /b < exitcodes>`在批处理文件的末尾返回自定义返回代码

- 环境变量`％errorlevel％`包含批处理文件中的最新错误级别，这是执行的最后一个命令的最新错误代码

**例：**

```shell
if not exist c:\lists.txt exit 7         # 如果找不到名为lists.txt的文件，将errorlevel设置为7
if not defined userprofile exit 9        # 如果变量userprofile未定义，将errorlevel设置为9
exit 0
```

